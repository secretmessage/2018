<html>
<body>

CS 332/780: Object-Oriented Databases &nbsp;&nbsp; Spring 2018
<br>
Course Notes #8
<br>
Keitaro Yukawa
<br>
Department of Computer Science
<br>
Queens College, CUNY

<br><br>

<font face="verdana" size=-1>

A characteristic of many object-oriented database systems is that
queries can be composed in two ways:

<ul>
<li>
<b>Using a declarative query language</b>.
The declarative nature of query languages allows faster, easier, and
less error-prone query compositions.
But the user has little control over efficiency of query execution and
has to accept the efficiency provided by the query processor/optimizer.
<li>
<b>Coding queries by algorithmic means</b>.
Coding queries by algorithmic means is a more difficult, time-consuming, and error-prone process.
But the payoff is greater control over efficiency;
the user can "hand optimize" queries by clever algorithmic coding and
can better estimate their efficiency.
Databases for many scientific and engineering application domains,
and for data mining and knowledge discovery, require highly efficient queries
and/or specialized queries that cannot be expressed by built-in declarative query languages.
For example, databases storing large networks might need sophisticated, efficient graph algorithms.

</ul>

The two modes of query composition can be mixed within the single framework of
the supported object-oriented database language.

<br><br>

In this course we study basic aspects of the <i>Java Data Objects</i> (<i>JDO</i>) standard 
developed by Sun Microsystems as an example of OODB.
JDO's data definition and application development languages are simply Java itself,
and its data manipulation language is provided in the <i>javax.jdo</i> package.
Salient characteristics of JDO are:

<ul>
<li>
OODB architecture specifically designed for Java persistent classes
<li>
Intended for both
  <ul>
  <li>transparent persistent object store systems
  <li>object-relational mapping systems
  </ul>
<li>
Implemented by Java APIs and annotations rather than by language extension
<li>
Required to be implemented in javax.jdo package containing three interfaces:
  <ul>
  <li>
  <b>javax.jdo.PersistenceManager</b>:
  Manages low-level, physical storage/file structures, creation and deletion of persistent objects, indexes,
  binding of class schemas and function code to database files.
  <li>
  <b>javax.jdo.Query</b>:
  Handles query compilation, optimization, and processing.
  <li>
  <b>javax.jdo.Transaction</b>:
  Manages concurrency control and error recovery.
  </ul>
Each of the three interfaces has a standard set of functions implementing the necessary functionalities.
</ul>

JDO has been implemented as transparent persistent object store systems
(e.g., ObjectDB) and as object-relational mapping systems (e.g., DataNucleus).
ObjectDB will be used in this course.

<br><br>

We will focus on <i>JDOQL</i>,
the declarative query language of JDO.
As will be described shortly,
it relies heavily on existentially quantified variables used in conjunction with
the membership-test function <i>contains</i> in the Collection interface.
Algorithmic queries in JDO are coded by means of built-in functions
in the Collection interface together with usual Java features and can be mixed
with declarative JDOQL queries.

</font>

<font face="verdana">
<center>
<h2>
Persistent Types Supported in ObjectDB
</h2>
</center>
</font>

<font face="verdana" size=-1>

<ul>
<li>
primitive types:
boolean, byte, short, int, long, float, double, char
<li>
arrays of elements of persistent types
<li>
user-defined persistent classes
<li>
from <i>java.lang</i> and <i>java.math</i> packages: the classes in Diagram 1
<li>
from <i>java.util</i> package: the interfaces and classes in Diagram 2
</ul>

<br>
<center><img src="java.lang.svg"></center>
<br><br><br>
<center><img src="java.util.svg"></center>
<br>

<center>
<h3>
Utility Functions in Collection&lt;E&gt; Interface
</h3>

</center>

In the following the variable <i>x</i> represents the target collection of functions and 
is assumed to be of type Collection&lt;E&gt;.
The generic type Collection&lt;?&gt; denotes Collection of elements of any type, which may differ from E.

<ul>
<li>boolean  x.contains(Object o) &nbsp;  Tests if o &isin; x. 
<li>boolean  x.containsAll(Collection&lt;?&gt; c) &nbsp;  Tests if c &sube; x. 
<li>boolean  x.equals(Object o) &nbsp;  Tests if x = o. There are two different interpretations of "equality" of collections. 
    One method makes "reference comparison", i.e., compares the references to <i>x</i> and <i>o</i>; 
    the other makes "value comparison", i.e., checks if <i>x</i> and <i>o</i> contain the same elements. 
    The Collection interface itself does not stipulate which method is to be implemented. 
    However, the Set and List interfaces do stipulate the implementation of value comparison. 
<li>boolean  x.isEmpty( ) &nbsp;  Tests if <i>x</i> is the empty collection. 
<li>int  x.size( ) &nbsp;  Returns the number of elements in <i>x</i>.
</ul>

The following functions return true if and only if the target collection <i>x</i> has changed 
as a result of the function call.
The <i>bounded generic type</i> Collection&lt;? extends E&gt; denotes Collection of 
elements of type E or any of E's descendant classes.

<ul> 
<li>boolean  x.add(E e) &nbsp;  x = x &cup; {e} 
<li>boolean  x.addAll(Collection&lt;? extends E&gt; c) &nbsp;  x = x &cup; c 
<li>boolean  x.remove(Object o) &nbsp;  x = x &minus; {o} 
<li>boolean  x.removeAll(Collection&lt;?&gt; c) &nbsp;  x = x &minus; c 
<li>boolean  x.retainAll(Collection&lt;?&gt; c) &nbsp;  x = x &cap; c 
</ul>

</font>

<font face="verdana">
<center>
<h2>
Basic JDO Operations
</h2>
</center>
</font>

<font face="verdana" size=-1>

JDO database operations are executed via PersistenceManager objects,
so the first step is to acquire a PersistenceManager object associated with a database file.

</font>
<pre>
PersistenceManager pm = Utilities.getPersistenceManager("foo.odb");
</pre>
<font face="verdana" size=-1>

This acquires a PersistenceManager object associated with the database file <i>foo.odb</i> and
assigns it to the variable <i>pm</i>;
if <i>foo.odb</i> does not exist, it will be created.
<i>Utilities</i> is an interface in the <i>com.objectdb</i> package.

<br><br>

New persistent objects are created by the standard constructor and
the <i>makePersistent</i> function.

</font>
<pre>
C x = new C(); // a new C-object is constructed in main memory or work storage
pm.makePersistent(x); // the C-object is made persistent and stored in the database file 
                      // associated with <i>pm</i>, in this example <i>foo.odb</i>
</pre>
<font face="verdana" size=-1>

<b>Persistence-By-Reachability Rule</b>:
Any new non-persistent object that is reachable from an existing persistent object by
a chain of references is automatically made persistent.
So the <i>makePersistent</i> function need not be applied to such objects.
For example:

</font>
<pre>
Student s = new Student();
pm.makePersistent(s);
Name n = new Name();
s.name = n; // n is reachable from persistent s and made persistent automatically

Take t = new Take();
s.take.add(t); // t is reachable from persistent s and made persistent automatically
</pre>
<font face="verdana" size=-1>

Persistent objects are deleted by application of the <i>deletePersistent</i> function.

</font>
<pre>
C x = ... retrieve a persistent object by a query ...;
pm.deletePersistent(x);
</pre>
<font face="verdana" size=-1>

Any statement that updates the database must be executed in a transaction.
Examples are creation and deletion of persistent objects and
updating of field values of persistent objects.

</font>
<pre>
pm.currentTransaction().begin();
...
statements to update the database
...
pm.currentTransaction().commit();
</pre>
<font face="verdana" size=-1>

Every PersistenceManager object <i>pm</i> automatically gets associated with a unique Transaction object 
that is responsible for concurrency control and error recovery of the database file bound to <i>pm</i>;
this Transaction object is obtained by the currentTransaction() function.

</font>

<font face="verdana">
<center>
<h2>
JDOQL Queries in Set Form
</h2>
</center>
</font>

<font face="verdana" size=-1>

The declarative query language of JDO, JDOQL, will be described.
JDOQL queries are composed by means of built-in functions in
the <i>javax.jdo.Query</i> interface.
Their understanding is facilitated by casting them
in the standard notation for sets and symbolic logic.
We will call them JDOQL queries in <em>set form</em>.
The set form expresses the declarative semantics of queries
with conciseness and precision.
We shall first study JDOQL in set form and then its translation into
the actual JDOQL syntax.

<br><br>

In this document, a <em>collection</em> will mean
an object of the Collection interface in Java or any of its descendants
that can be used as persistent types.

<br><br>

The general set form of JDOQL queries is:
<br><br>
{ x:C | B }
<br><br>
where
<ul>
<li>
 <i>x</i> is the <i>range variable</i>;
<li>
 <i>C</i> is a persistent class name or
 a Java expression denoting a collection of persistent objects;
<li>
 <i>B</i> is a Java Boolean expression 
 involving the range variable <i>x</i> and possibly variables distinct from <i>x</i>.
 <i>B</i> may use any library or user-defined functions that do not modify
 persistent objects or classes.
 <i>B</i> may also use the comparison operators ==, !=, <, >, <=, >= 
 for the following class types:
 String, Date, numeric wrapper types (Byte, Short, Integer, Long, Float, Double, Character),
 BigInteger, BigDecimal. 
</ul>
This form is interpreted as a query to retrieve the collection
of all objects <i>x</i> in the class/collection <i>C</i> that satisfy the 
Boolean expression <i>B</i>.
The variables in <i>B</i> distinct from <i>x</i> divide into two kinds:
<em>query parameters</em> and <em>existential variables</em>.
The existential variables in turn divide into two kinds:
<em>bound variables</em> and <em>unbound variables</em>.
<ul>
<li>
 <b>Query parameters</b>.
 Values of query parameters will be supplied when queries 
 are executed, just as values of function parameters are supplied
 when functions are called.
 For example, we may write a query to retrieve the student object with
 the student ID given as parameter value.
 Queries with parameters are called 
 <em>parametric queries</em>.
<li>
 <b>Existential variables</b>.
 Existential variables are those with the logical meaning of
 existential quantifiers &exist;<i>x</i>: "there exists <i>x</i> such that...".
 <ul>
 <li>
  <b>Bound variables</b>.
  Bound variables are those existential variables that appear as the parameter
  of the built-in <i>contains</i> function in the Collection interface.
  Its general form is <i>c</i>.contains(<i>x</i>) with a collection <i>c</i>.
  The logical meaning is: there exists <i>x</i> in the collection <i>c</i> such that...
  We use the notation &exist;<i>x</i>:<i>c</i> as its logical rendering.
  In logical rendering of bound variables in queries, 
  the existential quantifier &exist;<i>x</i>:<i>c</i>
  replaces the Java expression <i>c</i>.contains(<i>x</i>).
  As we will see in the examples to follow, bound variables can be used to
  traverse/compose binary relations.
 <li>
  <b>Unbound variables</b>.
  Unbound variables are those existential variables that do not appear as
  the parameter of the <i>contains</i> function (but may appear as a parameter
  of other functions).
  The type of each unbound variable must be a persistent class <i>C</i>,
  with the logical meaning: there exists <i>x</i> in the class <i>C</i> such that...
  We use the notation &exist;<i>x</i>:<i>C</i> as its logical rendering.
  In logical rendering of unbound variables in queries, 
  the existential quantifier &exist;<i>x</i>:<i>C</i>
  is placed before the boolean condition <i>B</i>.
 </ul>
</ul>

In evaluation of the Boolean expression <i>B</i>,
any attempt to access a field or a function through
a null reference will cause the smallest
surrounding Boolean subexpression to evaluate to
<i>false</i>. 
This is a difference from ordinary Java which will throw
NullPointer exceptions in those cases.
For example, suppose <i>B</i> has a subexpression
<i>p.teach.contains(c)</i> where <i>p</i> is 
a range variable of Professor type.
In case the value of <i>p.teach</i> is null,
the subexpression will evaluate to <i>false</i>.

<br><br>

The following examples are based on the Java code for the running college example
posted at http://picasso.cs.qc.cuny.edu/courseMaterial.html.
Its UML model is given in Course Notes #4. 
The Java classes are included here.
<pre>
public class Name
{
	String firstName;
	String lastName;
	String midInitial;

}

public abstract class Person
{
	Name name;
	String IDNum;
	String address;
	String homePhone;
	char gender; // 'f' = female, 'm' = male
}

public class Student extends Person
{
	String major;
	char program; // 'U' = undergraduate, 'M' = Master's, 'P' = PhD
	boolean hasGraduated;

	TreeSet&lt;Take&gt; take = new TreeSet&lt;Take&gt;();
	  // Implements the inverse of student: Take &rarr; Student  *, 1
	  // Sorted in chronological order of Take
}

public class OfficeInfo
{
	String roomNum;
	String building;
	String phoneNum;
}

public abstract class Employee extends Person
{
	OfficeInfo office;

	HashSet&lt;Employment&gt; employment = new HashSet&lt;Employment&gt;();
	  // Implements the inverse of employee: Employment &rarr; Employee  1..*,  1
}

public class Staff extends Employee
{

}

public class Professor extends Employee
{
	String rank; // current or latest rank
	boolean nowEmployed;

	HashSet&lt;CourseSection&gt; teach = new HashSet&lt;CourseSection&gt;();
	  // Implements teach: Professor &rarr; CourseSection  1..*, *
}

public class Course
{
	String number;
	String title;
	int credits;
	int hours;
	String description;

	TreeSet&lt;CourseSection&gt; courseSection = new TreeSet&lt;CourseSection&gt;(); 
	  // Implements courseSection: Course &rarr; CourseSection  1, *
	  // Sorted by (year, semester) of CourseSection in chronological order
}

public class CourseSection implements Comparable&lt;CourseSection&gt;
{
	String sectionCode;
	String registrationCode;
	int semester; /* 1 = winter session, 2 = spring, 3 = summer session I,
	                 4 = summer session II, 5 = fall */
	int year;

	Course course;
	  // Implements the inverse of courseSection: Course &rarr; CourseSection  1, *
 
	HashSet&lt;Take&gt; take = new HashSet&lt;Take&gt;(); 
	  // Implements the inverse of courseSection: Take &rarr; CourseSection  *, 1

	public int compareTo(CourseSection that)

	/* Compared by (year, semester) in chronological order.
	   In case "this" and "that" have the same (year, semester),
	   the ordering is resolved by registrationCode to be consistent with "equals". */

	{
		if ( this.year > that.year )
			return 1;
		else if ( this.year < that.year )
			return -1;
		else if ( this.semester > that.semester )
			return 1;
		else if ( this.semester < that.semester )
			return -1;
		else
			return this.registrationCode.compareTo(that.registrationCode);
	}
}

public class Take implements Comparable&lt;Take&gt;

/* Implements the 3-ary relation take(Student, CourseSection, Grade). */

{
	Student student;
	CourseSection courseSection;
	Grade grade;

	public int compareTo(Take that)

	/* Compared by the associated course sections in chronological order.
	   In case "this" and "that" have the same course section,
	   the ordering is resolved by student.IDNum to be consistent with "equals". */

	{
		int i = this.courseSection.compareTo(that.courseSection);
		if ( i != 0 )
			return i;
		else
			return this.student.IDNum.compareTo(that.student.IDNum);
	}
}

public class Grade
{
	String originalGrade;
	Date originalGradeDate;
	String updatedGrade;
	Date updatedGradeDate;
}

public class Office
{
	String officeName;
	OfficeInfo office;

	HashSet&lt;Employment&gt; employment = new HashSet&lt;Employment&gt;();
	  // Implements the inverse of office: Employment &rarr; Office  *, 1
}

public class Department extends Office
{
	Professor chairPerson;

	HashSet&lt;Course&gt; offer = new HashSet&lt;Course&gt;();
	  // Implements offer: Department &rarr; Course  1..*, *
}

public class Employment

/* Implements the ternary relation employment(Employee, Office, JobDescription).
   Since the employment relation instances and the JobDescription objects
   have 1:1 correspondence, the JobDescription class is dispensed with and 
   its attributes are incorporated into this class. */

{
	String positionTitle;
	Date startDate;
	Date endDate;

	Employee employee;
	Office office;
}
</pre>

<p>
<b>Example 1</b>
</font>
<pre>
{ s: Student | s.IDNum == "12345" }
</pre>
<font face="verdana" size=-1>
This retrieves the collection of students with the IDNum "12345".
Since the IDNum attribute is a key for the Student class,
the result collection will be empty or have just one student.
This query in set form has no parameters or existential variables.
</p>

<p>
<b>Example 2</b>
<br>
Parameter: ID: String
</font>
<pre>
{ s: Student | s.IDNum == ID }
</pre>
<font face="verdana" size=-1>
This is a parametric query that retrieves the student
whose IDNum is equal to the given value of <em>ID</em>.
</p>
 
<p>
<b>Example 3</b>
<br>
Parameters: regCode: String, sem: int, yr: int
</font>
<pre>
{ c: CourseSection | c.registrationCode == regCode &&
                     c.semester == sem &&
                     c.year == yr }
</pre>
<font face="verdana" size=-1>
This is a parametric query 
to retrieve the collection of course sections
whose registrationCode, semester, and year are respectively equal to
the given parameter values.
</p>

<p>
<b>Example 4</b>
<br>
Parameter: c: CourseSection
</font>
<pre>
{ p: Professor | p.teach.contains(c) }
</pre>
<font face="verdana" size=-1>
This is a parametric query to
retrieve the collection of professors that taught or are 
teaching the given course section <em>c</em>.
The field <i>p.teach</i> has the type HashSet&lt;CourseSection&gt; and stores teach&darr;CourseSection(<i>p</i>).
The query computes the "inverse" of this,
teach&darr;Professor(<i>c</i>).
Note that <i>c</i> is used as parameter, not as bound variable.
Whenever this query is executed,
a specific CourseSection object will be supplied as actual parameter value.
</p>

<p>
This is an example of a general pattern to compute inverses of binary relations.
As described in Course Notes #5,
a relation R: A &rarr; B can be implemented by:

</font>
<pre>
  class A
  { ...
    ...
    Set&lt;B&gt;  R;   // holds R&darr;B(a) = { b &in; B | R(a, b) }
  }
</pre>
<font face="verdana" size=-1>

The parametric query to retrieve R&darr;A(b) is:

<br><br>

Parameter: b: B

</font>
<pre>
{ a: A | a.R.contains(b) }
</pre>
<font face="verdana" size=-1>

</p>

<p>
<b>Example 5</b>
<br>
Bound variable: c: CourseSection
</font>
<pre>
{ p: Professor | p.teach.contains(c) && c.course.number == "CS313" }
</pre>
<font face="verdana" size=-1>
This retrieves the collection of professors that taught or are teaching a CS313 section.
Note the use of the existential variable <i>c</i> ranging over the collection
<i>p.teach</i>.
Its logical meaning is:
</font>
<pre>
{ p: Professor | &exist;c:p.teach (c.course.number == "CS313") }
</pre>
<font face="verdana" size=-1>
</p>

<p>
<b>Example 6</b>
<br>
Bound variable: c: CourseSection
</font>
<pre>
{ p: Professor | !(p.teach.contains(c) && c.course.number == "CS313") }
</pre>
<font face="verdana" size=-1>
This retrieves the collection of professors that have never taught a CS313 section.
Its logical meaning is:
</font>
<pre>
{ p: Professor | &not; &exist;c:p.teach (c.course.number == "CS313") }
</pre>
<font face="verdana" size=-1>
</p>

<p>
<b>Example 7</b>
<br>
Parameter: cNum: String
<br>
Bound variable: c: CourseSection
</font>
<pre>
{ p: Professor | p.teach.contains(c) && c.course.number == cNum }
</pre>
<font face="verdana" size=-1>
This parameterizes Example 5 by course number.
It retrieves the collection of professors that taught or are teaching 
a section of the course with the given course number <i>cNum</i>.
Its logical meaning is:
</font>
<pre>
{ p: Professor | &exist;c:p.teach (c.course.number == cNum) }
</pre>
<font face="verdana" size=-1>
</p>

<p>
<b>Example 8</b>
<br>
Parameter: c: Course
</font>
<pre>
{ d: Department | d.offer.contains(c) }
</pre>
<font face="verdana" size=-1>
A parametric query to retrieve the collection of
departments that offered or are offering the given course <em>c</em>.
It computes the inverse of the offer relation,
offer&darr;Department(<i>c</i>).
</p>

<p>
<b>Example 9</b>
<br>
Parameter: x: int
</font>
<pre>
{ c: CourseSection | c.take.size() >= x }
</pre>
<font face="verdana" size=-1>
A parametric query to retrieve all course sections taken by
at least <em>x</em> students.
<em>Size</em> is a library function in the Collection
interface that returns the number of elements in the collection. 
</p>

<p>
<b>Example 10</b>
<br>
Parameter: x: int
</font>
<pre>
{ s: Student | s.take.size() >= x }
</pre>
<font face="verdana" size=-1>
A parametric query to retrieve all students that have taken
at least <em>x</em> course sections.
</p>

<p>
<b>Example 11</b>
Let <i>totalCredits</i>() be a function in Student that computes
the total number of credits the target student has earned.
