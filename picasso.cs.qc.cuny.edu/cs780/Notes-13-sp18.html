<html>
<body>

CS 332/780: Object-Oriented Databases &nbsp;&nbsp; Spring 2018
<br>
Course Notes #13
<br>
Keitaro Yukawa
<br>
Department of Computer Science
<br>
Queens College, CUNY

<font face="verdana">

<center>
<h2>
Transaction Management
</h2>
</center>

</font>

<font face="verdana" size=-1>

The <em>transaction manager</em> (TM) is a component of a database system
with two main tasks:

<ul>
<li>
<b>Concurrency Control</b>.
Many database systems in operation today need to manage concurrent access to
the database by multiple users.
For example, a ticket reservation system must deal with multiple agents
concurrently attempting to reserve tickets for the same concert, airline flight, etc.
A college registration system must deal with concurrent registration requests
for the same course.
Improper management of concurrent operations 
could cause the database to have incorrect data, which, 
for example, would result in
overbooking or underbooking of an airline flight.
TM must ensure that incorrect data never result from concurrent operations
while allowing as much concurrency as possible or, at least, a reasonable
amount of concurrency.

<li>
<b>Recovery from Failure</b>.
Update operations on the database could fail because of unforeseen system malfunctions.
A system failure could occur in the midst of a ticket reservation session or
an ATM session requesting a withdrawal from a bank account.
If the effects of the session up to the point of failure are not
correctly handled, the database could end up with incorrect data
and the agent that initiated the session could face improper outcomes.
Examples: the ATM dispenses no money while the bank account gets deducted,
or no ticket is reserved while the credit card gets charged (as well as
their reverse effects like the ATM dispensing money but the bank account
never getting deducted!).  

</ul>

A <em>transaction</em> is a single <em>execution</em> of a code segment that
performs a well-defined, specific task involving operations on databases.
Multiple transactions of the same code segment may execute concurrently.
Transactions must have the following four properties, which came to be called
the "ACID" properties:

<ul>

<li>

<b>Atomicity</b>.

A transaction either is completely executed to its end or, if it fails 

to complete, has no effect at all as if it had never started.

This implies that if a transaction has had irrevocable effects before a failure,

it must be brought to completion as soon as possible after the failure.

<li>

<b>Consistency</b>.

A transaction maintains the consistency of the database, i.e.,

it never causes the database to have inconsistent data.

<li>

<b>Isolation</b>.

Although transactions may run concurrently, the overall effect of

the transactions is the same as some serial, non-concurrent execution of

them.

<li>

<b>Durability</b>.

Once a transaction has completed, its effect will be stored in the database until future updates.

</ul>

Atomicity has significance for failure recovery.

Whenever a transaction fails during its execution by whatever cause,

like an unforeseen runtime software error or a hardware/network failure,

all the partial effects it has had on the database must be undone,

or else its execution must be resumed and brought to completion.

Consider, for example, an ATM session to withdraw money from a bank account.

If a failure occurs after the deduction of the withdrawn amount from the account

but before the dispensation of the money, the transaction must be rolled back to

undo the account's deduction.

On the other hand, the transaction may be programmed to dispense the money first

and then deduct from the account.

In this case, if a failure occurs after the money dispensation but before

the account's deduction, the transaction must be rolled forward to completion

later because  money dispensation is irrevocable.

Consistency and Isolation are crucial for concurrency control,

and will be made precise by the concept of <em>serializability</em>.

<br><br>

This document deals only with concurrency control.
Those interested in failure recovery are referred to [1, 2].

<br><br>

</font>

<font face=verdana>

<b>1. Concurrency Model</b>

</font>

<br><br>

<font face="verdana" size=-1>

We begin with the standard concurrency model for database transactions.

Each transaction runs as an independent thread (i.e., process) with its own local memory.

A transaction's local memory contains data items and data structures

necessary for its independent execution.

Transactions communicate with a shared database by means of read and write operations.

A read operation moves a data item from

the database to the transaction's local memory, while

a write operation moves a data item from the local memory to the database.

Proper synchronization and mutual exclusion of concurrent transactions is

accomplished by controlling their read/write operations on

the shared database.

<br><br>

Transactions may run 

on the single-processor computer that has the database.

Their concurrent execution is accomplished by

splitting each transaction into <em>atomic operations</em>

and interleaving them (much as operating systems manage

concurrent processes on single-processor computers).

Every atomic operation is executed with no interleaving.

Read and write operations of data items are always executed as

atomic operations.

The exact nature of other kinds of atomic operations depends on a particular database system;

typical examples include:

(i) an evaluation of an expression,

(ii) an assignment operation, i.e., moving the value of a register or a memory location to

another location.

Updating a persistent object's field to the value of an expression <i>E</i>

might be split into:

</font>

<p style="page-break-before:always">

<pre>
read(object);
evaluate expression E and store the value at a memory location x;
assign the value at location x to object's field;
write(object);
</pre>

<font face=verdana size=-1>

Transactions can also be executed on a multi-processor computer,

each transaction with a dedicated processor.

Transactions may run on multiple computers connected to the database by a network.

On a database system with client-server architecture,

client computers may be physically remote from the server (the database) and

independently execute transactions with reading and writing of database items

performed over the network. In fact, transactions may run in any combination of

the above, e.g., over a network of remote computers, each running multiple

transactions on it.

<br><br>

The standard concurrency-control methods described in this document work

regardless of whether transactions are executed on a single-processor computer by interleaving,

on a multi-processor computer, on multiple computers over a network, or any

combination of them.

The only fundamental assumptions necessary for the concurrency model are:

<ol>

<li>
Each transaction runs as an independent thread (i.e., process) with its own local memory;

<li>
Transactions communicate with the shared database by means of read and write operations;

<li>
Every read or write operation is executed as atomic, isolated unit. 

</ol>

Allowing arbitrary temporal orderings of read/write operations of multiple transactions can

result in inconsistent data in the database.

Consider, for example, this transaction code segment to increment an integer database item A:

<br><br>

read(A); A = A+1; write(A);

<br><br>

We assume that this code has three atomic operations:

read(A), A=A+1, and write(A).

The read(A) operation brings the data item A from the database to a transaction's local memory,

"A=A+1" increments it, and write(A) moves the updated value back to the database.

We also assume A records the total number of seats reserved so far

and the code is executed whenever a new reservation is made.

Suppose that two concurrent transactions T<sub>1</sub> and T<sub>2</sub> on this code

have been executed with the following pattern

(with time flowing from left to right):

</font>

<br><br>

<table border=1 style='border-collapse: collapse;' width=90%>

<tr> 

<td>T<sub>1</sub></td>

<td>read(A)</td>

<td></td>

<td>A=A+1</td>

<td></td>

<td></td>

<td>write(A)</td>

</tr> 

<tr> 

<td>T<sub>2</sub></td>

<td></td>

<td>read(A)</td>

<td></td>

<td>A=A+1</td>

<td>write(A)</td>

<td></td>

</tr> 

<tr> 

<td>A's value in T<sub>1</sub>'s local memory</td>

<td>50</td>

<td>50</td>

<td>51</td>

<td>51</td>

<td>51</td>

<td>51</td>

</tr> 

<tr> 

<td>A's value in T<sub>2</sub>'s local memory</td>

<td></td>

<td>50</td>

<td>50</td>

<td>51</td>

<td>51</td>

<td></td>

</tr> 

<tr> 

<td>A's value in database</td>

<td>50</td>

<td>50</td>

<td>50</td>

<td>50</td>

<td>51</td>

<td>51</td>

</tr> 

</table> 

<br>

<font face="verdana" size=-1>

T<sub>1</sub> and T<sub>2</sub> may be executed

by interleaving on the same single-processor computer that has the database,

or by two different remote computers connected to the database by a network.

Starting from the initial value of A = 50, the database ends up with incorrect

value 51 instead of correct 52.

Clearly this will result in overbooking of seats.

Note that in each transaction, it does not matter exactly at what time between read(A)

and write(A) A = A+1 gets executed since it only changes A's value in respective local memory.

If T<sub>1</sub> and T<sub>2</sub> are running on

two remote computers, each transaction's A = A+1 may be executed at any time 

between its read(A) and write(A) - regardless,

the incorrect result is produced.

It is the temporal ordering of reads/writes that affects correctness of results.

In this simple example, we can intuitively see the source of the problem:

both transactions have been allowed to read the initial value of 50.
In fact, if <i>n</i> transactions, <i>n</i> &ge; 2, are allowed to read the initial value of 50,
the final value of A in the database will be 51 instead of correct 50+<i>n</i>,
since each of the <i>n</i> transactions will increment A to 51 in its local memory
and write it back in the database.

Therefore, we can see that once a transaction T on this code has read A,

no other transactions on this code should be allowed to read A until

T has written A.

This means that the only correct executions for transactions on this particular code

are serial executions with no concurrency.

This, however, is the consequence of the fact that this code

only involves a simple update of one data item.

In general, transactions involving a number of

operations on multiple data items may allow concurrent executions

that will produce correct results.

<br><br>

Informally, a <em>schedule</em> of transactions refers to a particular

temporal ordering of their read and write operations.

In general, it is too difficult and time consuming for TM to find,

on a case-by-case basis, a schedule that will produce correct results

with an optimal amount of concurrency or at least a reasonable amount of it.

Therefore, TM relies on a certain prescribed <em>scheduling protocol</em>

that is guaranteed to produce correct results, although schedules conforming to

the protocol may not yield optimal concurrency.

We will study three such protocols that utilize "lock" and "unlock" operations

on database items.

Before doing so, however, we need to define precisely what a "schedule" is

and what it means for transactions to produce "correct" results.

<br><br>

</font>

<font face=verdana>

<b>2. Serial and Serializable Schedules</b>

</font>

<font face=verdana size=-1>

<br><br>

A <em>schedule</em> for a set <i>S</i> of transactions is a linear

ordering of all the read and write operations of the transactions in <i>S</i>,

with the requirement that it preserve the ordering of the read/write operations within each

transaction.

A schedule represents a temporal ordering in which the transactions'

read/write operations would be executed on the database.

Let <i>&sigma;</i> be a schedule for a transaction set <i>S</i>.

For any two read or write operations <i>x</i>, <i>y</i> in <i>&sigma;</i>,

we write <i>x</i> &lt;<sub>&sigma;</sub> <i>y</i> if <i>x</i> precedes <i>y</i> 

in <i>&sigma;</i>, that is, <i>x</i> is executed before <i>y</i> in <i>&sigma;</i>.

A schedule <i>&sigma;</i> for <i>S</i> is called <em>serial</em> if for each transaction <i>T</i> &isin; <i>S</i>

and for any two operations <i>x</i>, <i>y</i> in <i>T</i> with

<i>x</i> &lt;<sub>&sigma;</sub> <i>y</i>,

each operation <i>z</i> such that <i>x</i> &lt;<sub>&sigma;</sub> <i>z</i> &lt;<sub>&sigma;</sub> <i>y</i>

belongs to <i>T</i>.

<br><br>

Example: Consider transactions T<sub>1</sub> containing read/write operations
a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub>,
T<sub>2</sub> containing b<sub>1</sub>, b<sub>2</sub>,
T<sub>3</sub> containing c<sub>1</sub>, c<sub>2</sub>, c<sub>3</sub>, c<sub>4</sub>.
One serial schedule for T<sub>1</sub>, T<sub>2</sub>, T<sub>3</sub> is:
b<sub>1</sub>, b<sub>2</sub>, c<sub>1</sub>, c<sub>2</sub>, c<sub>3</sub>, c<sub>4</sub>,
a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub>.
One non-serial schedule is:
a<sub>1</sub>, c<sub>1</sub>, b<sub>1</sub>, c<sub>2</sub>, a<sub>2</sub>, a<sub>3</sub>,
b<sub>2</sub>, c<sub>3</sub>, c<sub>4</sub>.

<br><br>

Note that the temporal ordering &lt;<sub>&sigma;</sub> is defined by the local time of the computer
running the database.
This is a non-trivial point if transactions are executing on remote computers operating, for example,
in spaceships or on Mars communicating to the database on earth.
A transaction executing on Mars may send a signal to request read(A) taking 10 minutes to reach
the database on earth.
The database processes it and dispatches the value of A to Mars, taking another 10 minutes to reach
the transaction.
It is the time that the database on earth processes read(A) that is used to determine &lt;<sub>&sigma;</sub>.
Likewise for write(A) operations.
(Electromagnetic signal needs about 4 to 21 minutes for a one-way trip between Mars and the earth
depending on the varying distances between them.)

<br><br>

<b>The database state 