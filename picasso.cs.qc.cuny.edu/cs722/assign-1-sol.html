<html>

<title>
CS 381/722 Assignment 1 Solutions
</title>

<body>

<center>
<h3>
CS 381/722 &nbsp;&nbsp; Fall 2018
<br>
Homework Assignment #1
<br>
Solutions
</h3>
</center>

In all questions "_" is the blank symbol.

<ol>

<li>
Consider the DTM to decide { w#w | w &isin; {0, 1}<sup>*</sup> } in Example 3.9 in the book.
Give the transition sequence on each of the following inputs:
<br><br>
  <ol type=a>
  <li>11#11
  <br><br>
  q<sub>1</sub>11#11 |&minus; <br>
  xq<sub>3</sub>1#11 |&minus; <br>
  x1q<sub>3</sub>#11 |&minus; <br>
  x1#q<sub>5</sub>11 |&minus; <br>
  x1q<sub>6</sub>#x1 |&minus; <br>
  xq<sub>7</sub>1#x1 |&minus; <br>
  q<sub>7</sub>x1#x1 |&minus; <br>
  xq<sub>1</sub>1#x1 |&minus; <br>
  xxq<sub>3</sub>#x1 |&minus; <br>
  xx#q<sub>5</sub>x1 |&minus; <br>
  xx#xq<sub>5</sub>1 |&minus; <br>
  xx#q<sub>6</sub>xx |&minus; <br>
  xxq<sub>6</sub>#xx |&minus; <br>
  xq<sub>7</sub>x#xx |&minus; <br>
  xxq<sub>1</sub>#xx |&minus; <br>
  xx#q<sub>8</sub>xx |&minus; <br>
  xx#xq<sub>8</sub>x |&minus; <br>
  xx#xxq<sub>8</sub>_ |&minus; <br>
  xx#xx_q<sub>accept</sub>_
  <br><br>

  <li>10#11
  <br><br>
  q<sub>1</sub>10#11 |&minus; <br>
  xq<sub>3</sub>0#11 |&minus; <br>
  x0q<sub>3</sub>#11 |&minus; <br>
  x0#q<sub>5</sub>11 |&minus; <br>
  x0q<sub>6</sub>#x1 |&minus; <br>
  xq<sub>7</sub>0#x1 |&minus; <br>
  q<sub>7</sub>x0#x1 |&minus; <br>
  xq<sub>1</sub>0#x1 |&minus; <br>
  xxq<sub>2</sub>#x1 |&minus; <br>
  xx#q<sub>4</sub>x1 |&minus; <br>
  xx#xq<sub>4</sub>1 |&minus; <br>
  xx#x1q<sub>reject</sub>_

  </ol>

<br>
 
<li>
Consider the NTM in
<a href="fa12-assign-1-sol.html">Question 2 here</a>.
Give the computation tree of this NTM on input string abcabc.

<br><br>

<center><img src="assign-1-sol-Q2.jpeg" width=700 height=450></center>

<br>

<li>
This question is about the simulation of multi-tape DTMs by 1-tape DTMs.
Consider the following configuration of a 4-tape DTM with &Gamma; = {a, b, c, _}:

<center><img src="assign-1-Q3.jpeg" width=500 height=350></center>

 <ol type=a>
 <li>Give the 1-tape DTM configuration simulating the above configuration.
 <li>Give the 1-tape DTM configuration simulating the configuration obtained by
     the 4-tape DTM transition
     &delta;(q<sub>i</sub>, c, c, b, a) = (q<sub>j</sub>, b, a, c, b, L, R, L, R) from the above configuration.
 </ol>

<center><img src="assign-1-sol-Q3.jpeg" width=700 height=230></center>
 
<br>

<li>
Recall the simulation of DTMs by RAMs described in class.

<br><br>

 <ol type=a>
 <li>Give the RAM memory configuration simulating
     a<sub>5</sub>a<sub>1</sub>a<sub>2</sub>a<sub>3</sub>q<sub>4</sub>a<sub>6</sub>a<sub>4</sub>.
 <li>Give the RAM memory configuration simulating the configuration obtained by the transition
     &delta;(q<sub>4</sub>, a<sub>6</sub>) = (q<sub>2</sub>, a<sub>2</sub>, L) from the above configuration.
 </ol>

<center><img src="assign-1-sol-Q4.jpeg" width=700 height=210></center>

<br>

<li>

Recall the simulation of RAMs by multi-tape DTMs described in class and
consider the RAM program to compute n! described on
<a href="notes/RAM.html">this page</a>.
Show the contents of tape 1 (simulating the RAM memory) and tape 2 (simulating the accumulator r<sub>0</sub>) after
the execution of each instruction in this RAM program up to the first execution of "Mult 3".
Use a format similar to
<a href="fa12-assign-1-sol.html">Question 5 on this page</a>, and
abbreviate integers in unary notation to decimal notation.

<br><br>

We may trace the execution for an example value of n like 3, 4, 5.
Here we show the values of the memory cells by general expressions of n &ge; 2.

<br><br>

Read 1
<blockquote>
tape 1: ##1#n##
<br>
tape 2: 0
</blockquote>

Load 1
<blockquote>
tape 1: ##1#n##
<br>
tape 2: n
</blockquote>

Store 2
<blockquote>
tape 1: ##1#n##2#n##
<br>
tape 2: n
</blockquote>

Sub =1
<blockquote>
tape 1: ##1#n##2#n##
<br>
tape 2: n&minus;1
</blockquote>

Store 3
<blockquote>
tape 1: ##1#n##2#n##3#n&minus;1##
<br>
tape 2: n&minus;1
</blockquote>

Load 3
<blockquote>
tape 1: ##1#n##2#n##3#n&minus;1##
<br>
tape 2: n&minus;1
</blockquote>

n&minus;1 &gt; 0, jump to "continue"

<br><br>

Load 2
<blockquote>
tape 1: ##1#n##2#n##3#n&minus;1##
<br>
tape 2: n
</blockquote>

Mult 3
<blockquote>
tape 1: ##1#n##2#n##3#n&minus;1##
<br>
tape 2: n*(n&minus;1)
</blockquote>

<li>
A second way to simulate multi-tape DTMs by 1-tape DTMs is to create segments of 
tape symbols with respect to tape positions separated by delimiter symbols.
The first segment contains the string of tape symbols at the first positions of k tapes,
the second segment contains the string of symbols at the second positions, etc.
The symbols being read by the tape heads are simulated by dotted symbols.
For example, the configuration of the 4-tape DTM given in Question 3 is simulated by the following configuration:

<center><img src="assign-1-Q6.jpeg" width=700 height=90></center>

  <ol type=a>
  <li>
  Give the 1-tape DTM configuration simulating the configuration obtained by
  the 4-tape DTM transition
  &delta;(q<sub>i</sub>, c, c, b, a) = (q<sub>j</sub>, b, a, c, b, L, R, L, R) from the above configuration.

  <center><img src="assign-1-sol-Q6.jpeg" width=730 height=90></center>

  <li>Informally but in sufficient detail, describe a general tape configuration of the simulating 1-tape DTM.
  <br><br>
  Let M be the given k-tape DTM to be simulated and
  let n be the length of the longest tape strings that have been written by M on any tapes.
  The general configuration of the simulating 1-tape DTM, M', is
  <br><br>
  #u<sub>1</sub># &hellip; #u<sub>n</sub>#_ _ _ &hellip;
  <br><br>
  where u<sub>i</sub>, 1 &le; i &le; n, is the string of k tape symbols,
  in order of tape 1, &hellip;, tape k, at position i.
  The k tape symbols being read by the tape heads are simulated by dotted symbols.
  <br><br>
  <li>Informally but in sufficient detail, describe how to simulate a one-step transition of the given multi-tape DTM
  in this method.
  <br><br>
  The following is an example simulation method.
  <br><br>
  The simulating 1-tape DTM, M', uses the special tilde tape symbols a<sup>~</sup> for each tape symbol a of M
  in addition to the dotted tape symbols indicating virtual heads.
  The "tape-head symbol" refers to the tape symbol being read by the tape head.
  <br><br>
  <ol type=i>
  <li>Scan the tape from left to right and determine the k dotted symbols.
      In each u<sub>i</sub> M' counts the offset number from its left delimiter #;
      this offset is used to determine the tape number of each dotted symbol.
      The last # after u<sub>n</sub> has been passed when the (k+1)-th offset position is a blank symbol instead of #;
      the scanning then terminates.
      Move the tape head back to the leftmost position.
  <li>From the k dotted symbols and their tape numbers, determine the instance of M's transition function to be simulated.
      Let this instance be:
      <br><br>
      &delta;(q<sub>i</sub>, a<sub>1</sub>, &hellip;, a<sub>k</sub>) = 
      (q<sub>j</sub>, b<sub>1</sub>, &hellip;, b<sub>k</sub>, d<sub>1</sub>, &hellip;, d<sub>k</sub>)
      <br><br>
  <li>Scan the tape from left to right.
      In each u<sub>i</sub> M' counts the offset number as in step (i) to determine the tape number of each dotted symbol.
      Whenever a dotted symbol is found at offset i, which is a tape number, perform the following, then the scanning continues.
      <br><br>
      <ol>
      <li>Replace the dotted a<sub>i</sub> by b<sub>i</sub>.
      <li>If d<sub>i</sub> = S (stationary),
          replace b<sub>i</sub> by the dotted b<sub>i</sub>.
          <br>
          If d<sub>i</sub> = L,
          move the tape head (k+1) positions to left, replace the tape-head symbol by its dotted symbol, and
          move the tape head back (k+1) positions to right.
          The exception is if the dotted symbol is found in u<sub>1</sub>;
          this special case is the same as a stationary case, so just replace b<sub>i</sub> by the dotted b<sub>i</sub>.
          <br>
          If d<sub>i</sub> = R,
          move the tape head (k+1) positions to right, replace the tape-head symbol a by a<sup>~</sup>, and
          move the tape head back (k+1) positions to left.
      </ol>
      <br>
      If a tilde symbol a<sup~</sup> is found at any point in the scanning process, replace it by the dotted symbol of a.
      <br><br>
      The last # after u<sub>n</sub> has been passed when the (k+1)-th offset position is a blank symbol instead of #;
      the scanning then terminates.
      If this last segment contained at least one tilde blank symbol,
      replace the blank symbol at the (k+1)-th offset position by #
      (effectively appending the new position segment u<sub>n+1</sub>).
  </ol>
  

  </ol>

<br>

<li>
The random access machine with increment and decrement instructions, abbreviated as RAM-Inc-Dec, replaces 
the <a href="notes/RAM.html">four arithmetic instructions Add, Sub, Mult, Div of the RAM</a> by the following two instructions:

<blockquote>
Inc &nbsp;&nbsp;&nbsp;&nbsp; r<sub>0</sub> &larr; r<sub>0</sub> + 1
<br>
Dec &nbsp;&nbsp;&nbsp; r<sub>0</sub> &larr; r<sub>0</sub> &minus; 1
</blockquote>

The other instructions remain the same.
You are to show that the computing powers of the RAM and RAM-Inc-Dec are equivalent in principle
by following the steps below.

<br><br>

<font color=red>
Quite a number of simulation methods exist.
The following is an example solution.
</font>

<br><br>

<ol type=a>
<li>
In detail, show how to simulate Add instruction by Inc, Dec instructions together with Load, Store,
and jump instructions.
First describe your simulation method in high-level pseudocode like the factorial example, then
translate it into instruction streams of RAM-Inc-Dec.
Note that values of r<sub>i</sub> and literal operands "=i" may be negative integers.

<br><br>

In the following simulation code,
r<sub>j</sub>, r<sub>k</sub>, r<sub>m</sub>, r<sub>n</sub>, r<sub>m1</sub>,
r<sub>p</sub>, r<sub>q</sub>, r<sub>s</sub>
are distinct memory cells not used anywhere else in the program;
r<sub>j</sub>, r<sub>k</sub> are reserved for simulation of Add and Sub,
r<sub>m</sub>, r<sub>n</sub>, r<sub>m1</sub> are reserved for simulation of Mult,
r<sub>p</sub>, r<sub>q</sub>, r<sub>s</sub> are reserved for simulation of Div.

<br><br>

<b>Simulation of Add =i, r<sub>0</sub> &larr; r<sub>0</sub> + i.</b>

<pre>
r<sub>j</sub> &larr; r<sub>0</sub>; // move the value of r<sub>0</sub> to r<sub>j</sub> to free up r<sub>0</sub> for computation
r<sub>k</sub> &larr; i;
<b>if</b> ( r<sub>k</sub> &gt; 0 ) // i &gt; 0
{
	<b>while</b> ( r<sub>k</sub> &gt; 0 ) // increment the value of r<sub>j</sub> r<sub>k</sub> times
	{
		r<sub>j</sub> &larr; r<sub>j</sub>+1;
		r<sub>k</sub> &larr; r<sub>k</sub>&minus;1;
	}
	r<sub>0</sub> &larr; r<sub>j</sub>; // move the value of r<sub>j</sub> = (original value of r<sub>0</sub>)+i to r<sub>0</sub>
	Halt;
}
<b>else</b> // r<sub>k</sub> &le; 0, i &le; 0
{
	<b>while</b> ( r<sub>k</sub> &ne; 0 ) // decrement the value of r<sub>j</sub> |r<sub>k</sub>| times
	{
		r<sub>j</sub> &larr; r<sub>j</sub>&minus;1;
		r<sub>k</sub> &larr; r<sub>k</sub>+1;
	}
	r<sub>0</sub> &larr; r<sub>j</sub>; // move the value of r<sub>j</sub> = (original value of r<sub>0</sub>)&minus;|i| to r<sub>0</sub>
	Halt;
}
</pre>

<pre>
           Store j         // r<sub>j</sub> &larr; r<sub>0</sub>
           Load =i         // r<sub>0</sub> &larr; i
           Store k         // r<sub>k</sub> &larr; r<sub>0</sub>
           Jgtz while1     // if r<sub>0</sub> &gt; 0 then jump to "while1"
           Jump while2     // jump to "while2"
while1:    Load k          // r<sub>0</sub> &larr; r<sub>k</sub>
           Jgtz continue   // if r<sub>0</sub> &gt; 0 then jump to "continue"
           Jump endWhile1  // jump to "endWhile1"
continue:  Load j          // r<sub>0</sub> &larr; r<sub>j</sub>
           Inc             // r<sub>0</sub> &larr; r<sub>0</sub>+1
           Store j         // r<sub>j</sub> &larr; r<sub>0</sub>
           Load k          // r<sub>0</sub> &larr; r<sub>k</sub>
           Dec             // r<sub>0</sub> &larr; r<sub>0</sub>&minus;1
           Store k         // r<sub>k</sub> &larr; r<sub>0</sub>
           Jump while1     // jump to "while1"
endWhile1: Load j          // r<sub>0</sub> &larr; r<sub>j</sub>
           Halt
while2:    Load k          // r<sub>0</sub> &larr; r<sub>k</sub>
           Jzero endWhile2 // if r<sub>0</sub> = 0 then jump to "endWhile2"
           Load j          // r<sub>0</sub> &larr; r<sub>j</sub>
           Dec             // r<sub>0</sub> &larr; r<sub>0</sub>&minus;1
           Store j         // r<sub>j</sub> &larr; r<sub>0</sub>
           Load k          // r<sub>0</sub> &larr; r<sub>k</sub>
           Inc             // r<sub>0</sub> &larr; r<sub>0</sub>+1
           Store k         // r<sub>k</sub> &larr; r<sub>0</sub>
           Jump while2     // jump to "while2"
endWhile2: Load j          // r<sub>0</sub> &larr; r<sub>j</sub>
           Halt
</pre>

<b>Simulation of Add i, r<sub>0</sub> &larr; r<sub>0</sub> + r<sub>i</sub>.</b>
In the above pseudocode, replace the 2nd statement "r<sub>k</sub> &larr; i" by
"r<sub>k</sub> &larr; r<sub>i</sub>" and in the RAM-Inc-Dec program,
replace the 2nd instruction "Load =i" by "Load i".
<br><br>
<li>
Describe clearly how to simulate Sub, Mult, Div instructions with help of high-level pseudo code;
no need to translate the pseudocode into instruction streams of RAM-Inc-Dec.
You may use previously simulated instructions as "subroutines" to simulate a new instruction.
For example, you may use the RAM-Inc-Dec code simulating Add instruction as a subroutine to
simulate Sub instruction, then use Add and/or Sub instructions as subroutines to simulate
Mult and/or Div.

<br><br>

<b>Simulation of Sub =i, r<sub>0</sub> &larr; r<sub>0</sub> &minus; i.</b>
The effect of Sub instruction is positive/negative-symmetric to Add instruction.
That is, "Sub =i" is equivalent to "Add =(&minus;i)", similarly for "Sub i".
The following pseudocode implements this idea.

<pre>
r<sub>j</sub> &larr; r<sub>0</sub>; // move the value of r<sub>0</sub> to r<sub>j</sub> to free up r<sub>0</sub> for computation
r<sub>k</sub> &larr; i;
<b>if</b> ( r<sub>k</sub> &gt; 0 ) // i &gt; 0
{
	<b>while</b> ( r<sub>k</sub> &gt; 0 ) // decrement the value of r<sub>j</sub> r<sub>k</sub> times
	{
		r<sub>j</sub> &larr; r<sub>j</sub>&minus;1;
		r<sub>k</sub> &larr; r<sub>k</sub>&minus;1;
	}
	r<sub>0</sub> &larr; r<sub>j</sub>; // move the value of r<sub>j</sub> = (original value of r<sub>0</sub>)&minus;i to r<sub>0</sub>
	Halt;
}
<b>else</b> // r<sub>k</sub> &le; 0, i &le; 0
{
	<b>while</b> ( r<sub>k</sub> &ne; 0 ) // increment the value of r<sub>j</sub> |r<sub>k</sub>| times
	{
		r<sub>j</sub> &larr; r<sub>j</sub>+1;
		r<sub>k</sub> &larr; r<sub>k</sub>+1;
	}
	r<sub>0</sub> &larr; r<sub>j</sub>; // move the value of r<sub>j</sub> = (original value of r<sub>0</sub>)+|i| to r<sub>0</sub>
	Halt;
}
</pre>

<b>Simulation of Sub i, r<sub>0</sub> &larr; r<sub>0</sub> &minus; r<sub>i</sub>.</b>
In the above pseudocode, replace the 2nd statement "r<sub>k</sub> &larr; i" by
"r<sub>k</sub> &larr; r<sub>i</sub>".

<br><br>

<b>Simulation of Mult =i, r<sub>0</sub> &larr; r<sub>0</sub> * i.</b>

<pre>
r<sub>m</sub> &larr; r<sub>0</sub>; // move the value of r<sub>0</sub> to r<sub>m</sub> to free up r<sub>0</sub> for computation
r<sub>n</sub> &larr; i;
r<sub>m1</sub> &larr; 0;
<b>if</b> ( r<sub>n</sub> &gt; 0 )
{
       // cumulatively add r<sub>m</sub> to 0 i times
	<b>while</b> ( r<sub>n</sub> &gt; 0 )
	{
		r<sub>m1</sub> &larr; r<sub>m1</sub>+r<sub>m</sub>; // implemented by Load m1; Add m; Store m1;
		r<sub>n</sub> &larr; r<sub>n</sub>&minus;1;
	}
	r<sub>0</sub> &larr; r<sub>m1</sub>;
	Halt;
}
<b>else</b> // r<sub>n</sub> &le; 0
{
       // cumulatively subtract r<sub>m</sub> from 0 |i| times
	<b>while</b> ( r<sub>n</sub> &ne; 0 )
	{
		r<sub>m1</sub> &larr; r<sub>m1</sub>&minus;r<sub>m</sub>; // implemented by Load m1; Sub m; Store m1;
		r<sub>n</sub> &larr; r<sub>n</sub>+1;
	}
	r<sub>0</sub> &larr; r<sub>m1</sub>;
	Halt;
}
</pre>

<b>Simulation of Mult i, r<sub>0</sub> &larr; r<sub>0</sub> * r<sub>i</sub>.</b>
In the above pseudocode, replace the 2nd statement "r<sub>n</sub> &larr; i" by
"r<sub>n</sub> &larr; r<sub>i</sub>".

<br><br>

Simulation of "Div" instruction converts the negative operands to positive values,
computes the quotient of two positive values, then
converts the quotient to its negative, and decrement by 1, if necessary.
To this effect, the following "Div+" macro code is used:

<pre>
// It is assume that r<sub>p</sub> &gt; 0 and r<sub>q</sub> &gt; 0.
// This macro code computes r<sub>s</sub> &larr; &lfloor;r<sub>p</sub>/r<sub>q</sub>&rfloor;.

r<sub>s</sub> &larr; 0;
r<sub>p</sub> &larr; r<sub>p</sub>&minus;r<sub>q</sub>;
<b>while</b> ( r<sub>p</sub> &ge; 0 )
{
	r<sub>s</sub> &larr; r<sub>s</sub>+1;
	r<sub>p</sub> &larr; r<sub>p</sub>&minus;r<sub>q</sub>;
}
</pre>

<b>Simulation of Div =i, r<sub>0</sub> &larr; &lfloor;r<sub>0</sub> / i&rfloor;.</b>
It is assumed i &ne; 0.

<pre>
r<sub>p</sub> &larr; r<sub>0</sub>;
r<sub>q</sub> &larr; i;
<b>if</b> ( r<sub>p</sub> &gt; 0 )
{
	<b>if</b> ( r<sub>q</sub> &gt; 0 )
		Div+; // r<sub>s</sub> &larr; &lfloor;r<sub>p</sub>/r<sub>q</sub>&rfloor;
	<b>else</b> // r<sub>q</sub> &lt; 0
	{
		r<sub>q</sub> &larr; 0-r<sub>q</sub>; // negate the value of r<sub>q</sub>
		Div+; // r<sub>s</sub> &larr; &lfloor;r<sub>p</sub>/r<sub>q</sub>&rfloor;
		r<sub>s</sub> &larr; 0-r<sub>s</sub>; // negate the value of r<sub>s</sub>
		<b>if</b> ( r<sub>p</sub>+r<sub>q</sub> &ne; 0 ) // r<sub>0</sub> is not divisible by i
			r<sub>s</sub> &larr; r<sub>s</sub>&minus;1;
	}
}
<b>else</b> // r<sub>p</sub> &le; 0
{
	r<sub>p</sub> &larr; 0&minus;r<sub>p</sub>; // negate the value of r<sub>p</sub>
	<b>if</b> ( r<sub>q</sub> &gt; 0 )
	{
		Div+; // r<sub>s</sub> &larr; &lfloor;r<sub>p</sub>/r<sub>q</sub>&rfloor;
		r<sub>s</sub> &larr; 0-r<sub>s</sub>; // negate the value of r<sub>s</sub>
		<b>if</b> ( r<sub>p</sub>+r<sub>q</sub> &ne; 0 ) // r<sub>0</sub> is not divisible by i
			r<sub>s</sub> &larr; r<sub>s</sub>&minus;1;
	}
	<b>else</b> // r<sub>q</sub> &lt; 0
	{
		r<sub>q</sub> &larr; 0-r<sub>q</sub>; // negate the value of r<sub>q</sub>
		Div+; // r<sub>s</sub> &larr; &lfloor;r<sub>p</sub>/r<sub>q</sub>&rfloor;
	}
}
r<sub>0</sub> &larr; r<sub>s</sub>;
Halt;
</pre>

<b>Simulation of Div i, r<sub>0</sub> &larr; &lfloor;r<sub>0</sub> / r<sub>i</sub>&rfloor;.</b>
It is assumed r<sub>i</sub> &ne; 0.
In the above pseudocode, replace the 2nd statement "r<sub>q</sub> &larr; i" by
"r<sub>q</sub> &larr; r<sub>i</sub>".

</ol>
</ol>

</body>
</html>
