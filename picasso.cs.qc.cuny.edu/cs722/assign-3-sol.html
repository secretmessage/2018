<html>

<title>
CS 722 Assignment 3 Solutions
</title>

<body>

<center>
<h3>
CS 722 &nbsp;&nbsp; Fall 2017
<br>
Homework Assignment #3
<br>
Solutions
</h3>
</center>

<ol>

<li>
Consider the polynomial-time reduction 3SAT &le;<sub>p</sub> VERTEX-COVER we studied in class
and the following &phi;:

<blockquote>
&phi; =
(x<sub>1</sub> &or; x<sub>2</sub> &or; x<sub>3</sub>) &and;
(&not;x<sub>1</sub> &or; x<sub>2</sub> &or; x<sub>3</sub>) &and;
(&not;x<sub>1</sub> &or; x<sub>2</sub> &or; &not;x<sub>3</sub>) &and;
(x<sub>1</sub> &or; &not;x<sub>2</sub> &or; &not;x<sub>3</sub>) &and;
(&not;x<sub>1</sub> &or; &not;x<sub>2</sub> &or; &not;x<sub>3</sub>)
</blockquote>

Here, &not;x<sub>i</sub> is the negation of x<sub>i</sub>.
<br><br>

  <ol type=a>
  <li>
  Give (G<sub>&phi;</sub>, k) constructed from &phi; by the reduction.
  <br><br>
  (G<sub>&phi;</sub>, k) is given in (b) and (c).
  <br><br>
  </li>
  <li>
  Give one satisfying assignment for &phi;, and a corresponding k-vertex cover for G<sub>&phi;</sub>
  produced by the equivalence proof.
  <br><br>
  The 13-vertex cover is shown in green.
  <br><br>
  <img src="assign-3-sol-Q1-1.svg" width=800>
  <br><br>
  </li>
  <li>
  Give one k-vertex cover for G<sub>&phi;</sub> that is distinct from the one you gave in (b), and
  give a corresponding assignment for &phi; produced by the equivalence proof.
  <br><br>
  The 13-vertex cover is shown in green.
  <br><br>
  <img src="assign-3-sol-Q1-2.svg" width=800>
  <br><br>
  </li>
  </ol>

<br>

<li>
Consider the polynomial-time reduction 3SAT &le;<sub>p</sub> SUBSET-SUM we studied in class
and the same &phi; in Question (1).
<br><br>

  <ol type=a>
  <li>
  Give the "sum table" constructed from &phi; by the reduction.
  <br><br>
  The sum table is given in (b) and (c).
  <br><br>
  </li>
  <li>
  Give one satisfying assignment for &phi;, and a corresponding subset
  produced by the equivalence proof.
  <pre>
            1   2   3    C<sub>1</sub>    C<sub>2</sub>    C<sub>3</sub>    C<sub>4</sub>    C<sub>5</sub>

     X<sub>1</sub>     1   0   0    1     0     0     1     0
    <font color=red>&not;X<sub>1</sub>     1   0   0    0     1     1     0     1</font>
     X<sub>2</sub>         1   0    1     1     1     0     0
    <font color=red>&not;X<sub>2</sub>         1   0    0     0     0     1     1</font>
     <font color=red>X<sub>3</sub>             1    1     1     0     0     0</font>
    &not;X<sub>3</sub>             1    0     0     1     1     1

     <font color=red>g<sub>1</sub>                  1     0     0     0     0</font>
     <font color=red>h<sub>1</sub>                  1     0     0     0     0</font>
     <font color=red>g<sub>2</sub>                        1     0     0     0</font>
     h<sub>2</sub>                        1     0     0     0
     <font color=red>g<sub>3</sub>                              1     0     0</font>
     <font color=red>h<sub>3</sub>                              1     0     0</font>
     <font color=red>g<sub>4</sub>                                    1     0</font>
     <font color=red>h<sub>4</sub>                                    1     0</font>
     <font color=red>g<sub>5</sub>                                          1</font>
     h<sub>5</sub>                                          1

     t      1   1   1    3     3     3     3     3
  </pre>
  A = { x<sub>1</sub> = 0, x<sub>2</sub> = 0, x<sub>3</sub> = 1 },
  S' = { &not;X<sub>1</sub>, &not;X<sub>2</sub>, X<sub>3</sub>, g<sub>1</sub>, h<sub>1</sub>, g<sub>2</sub>,
         g<sub>3</sub>, h<sub>3</sub>, g<sub>4</sub>, h<sub>4</sub>, g<sub>5</sub> }.
  <br><br>
  </li>
  <li>
  Give one subset that sums to t and is distinct from the one you gave in (b), and
  give a corresponding assignment for &phi; produced by the equivalence proof.
  <pre>
            1   2   3    C<sub>1</sub>    C<sub>2</sub>    C<sub>3</sub>    C<sub>4</sub>    C<sub>5</sub>

     X<sub>1</sub>     1   0   0    1     0     0     1     0
    <font color=red>&not;X<sub>1</sub>     1   0   0    0     1     1     0     1</font>
     <font color=red>X<sub>2</sub>         1   0    1     1     1     0     0</font>
    &not;X<sub>2</sub>         1   0    0     0     0     1     1
     X<sub>3</sub>             1    1     1     0     0     0
    <font color=red>&not;X<sub>3</sub>             1    0     0     1     1     1</font>

     <font color=red>g<sub>1</sub>                  1     0     0     0     0</font>
     <font color=red>h<sub>1</sub>                  1     0     0     0     0</font>
     <font color=red>g<sub>2</sub>                        1     0     0     0</font>
     h<sub>2</sub>                        1     0     0     0
     g<sub>3</sub>                              1     0     0
     h<sub>3</sub>                              1     0     0
     <font color=red>g<sub>4</sub>                                    1     0</font>
     <font color=red>h<sub>4</sub>                                    1     0</font>
     <font color=red>g<sub>5</sub>                                          1</font>
     h<sub>5</sub>                                          1

     t      1   1   1    3     3     3     3     3
  </pre>
  S' = { &not;X<sub>1</sub>, X<sub>2</sub>, &not;X<sub>3</sub>, g<sub>1</sub>, h<sub>1</sub>, g<sub>2</sub>,
         g<sub>4</sub>, h<sub>4</sub>, g<sub>5</sub> },
  A = { x<sub>1</sub> = 0, x<sub>2</sub> = 1, x<sub>3</sub> = 0 }.
  </li>
  </ol>

<br>

<li>
Consider the polynomial-time reduction 3SAT &le;<sub>p</sub> HAMPATH we studied in class
and the following &phi;:

<blockquote>
&phi; =
(x<sub>1</sub> &or; x<sub>1</sub> &or; x<sub>2</sub>) &and;
(x<sub>1</sub> &or; x<sub>2</sub> &or; &not;x<sub>2</sub>) &and;
(&not;x<sub>1</sub> &or; &not;x<sub>2</sub> &or; &not;x<sub>2</sub>)
</blockquote>

  <ol type=a>
  <li>
  Give (G<sub>&phi;</sub>, s, t) constructed from &phi; by the reduction.
  <br><br>
  (G<sub>&phi;</sub>, s, t) is given in (b) and (c).
  <br><br>
  </li>
  <li>
  Give one satisfying assignment for &phi;, and a corresponding Ham path from s to t in G<sub>&phi;</sub>
  produced by the equivalence proof.
  <br><br>
  The Hamiltonian path is shown in red.
  <br><br>
  <img src="assign-3-sol-Q3-1.svg" width=800>
  <br><br>
  </li>
  <li>
  Give one Ham path from s to t that is distinct from the one you gave in (b), and
  give a corresponding assignment for &phi; produced by the equivalence proof.
  <br><br>
  The Hamiltonian path is shown in red.
  <br><br>
  <img src="assign-3-sol-Q3-2.svg" width=800>
  </li>
  </ol>

<br>

<li>
Problem 7.17 on page 323 (Problem 7.16 in the 2nd edition).

<br><br>
If all numbers are represented in unary,
the size of the sum table is exponential in the number of literals in the given 3-cnf-formula,
so the runtime of the reduction is not bounded by a polynomial.
<br><br>
Let &lang;x<sub>1</sub>, &hellip;, x<sub>k</sub>, t&rang; be an input where the x<sub>i</sub> and t are given in unary.
Let n = size of  &lang;x<sub>1</sub>, &hellip;, x<sub>k</sub>, t&rang;.
<br><br>
Let S(i, j), 0 &le; i &le; k, 0 &le; j &le; t, be the Boolean function defined by:
<br><br>
S(i, j) = true iff there is a subset of { x<sub>1</sub>, &hellip;, x<sub>i</sub> } that sums to j.
<br><br>
Then the following recurrence holds:
<br><br>
S(i, 0) = true, 0 &le; i &le; k
<br>
S(0, j) = false, 1 &le; j &le; t
<br>
S(i, j) =
<br>
(there is a subset of { x<sub>1</sub>, &hellip;, x<sub>i&minus;1</sub> } that sums to j) &or;
(there is a subset of { x<sub>1</sub>, &hellip;, x<sub>i</sub> } using x<sub>i</sub> that sums to j) =
<br>
(there is a subset of { x<sub>1</sub>, &hellip;, x<sub>i&minus;1</sub> } that sums to j) &or;
(there is a subset of { x<sub>1</sub>, &hellip;, x<sub>i&minus;1</sub> } that sums to j&minus;x<sub>i</sub>) =
<br>
S(i&minus;1, j) &or; S(i&minus;1, j&minus;x<sub>i</sub>)
<br><br>
A dynamic programming algorithm can be used to compute S(k, t) by calculating the entries of
(k+1) &times; (t+1) 2-dimensional table in row-major order using the above recurrence.
It holds that k &le; n.
Since t is in unary, the value of t is the length of t, hence t &le; n.
The runtime is thus O(k&times;t) = O(n&times;n) = O(n<sup>2</sup>).
If the x<sub>i</sub> and t are encoded by a p-radix notation, p &ge; 2,
size(t) &approx; log<sub>p</sub>t.
Hence t = p<sup>log<sub>p</sub>t</sup> &approx; p<sup>size(t)</sup>, and
the value of t
cannot be bounded by a polynomial of the size of &lang;x<sub>1</sub>, &hellip;, x<sub>k</sub>, t&rang;.
<br><br>

<li>
Problem 7.41 on page 327 (Problem 7.39 in the 2nd edition).

<br><br>
If 2 &times; 2 windows are used, Claim 2 breaks down: Even if the i-th row is a valid configuration and
every 2 &times; 2 window over the i-th and (i+1)-th rows is legal,
the (i+1)-th row may not be a valid configuration.
For example, let &delta;(q, b) = { (q', a, L), (q', a, R) }.
The following i-th and (i+1)-th rows are allowed:
<pre>
     &middot;&middot;&middot; a q b  &middot;&middot;&middot;
     &middot;&middot;&middot; q'a q' &middot;&middot;&middot;
</pre>
Every 2 &times; 2 window over these rows is legal, but the (i+1)-th row is not a valid configuration.
<br><br>
Another example is:
<pre>
     &middot;&middot;&middot; b b b &middot;&middot;&middot; q b b &middot;&middot;&middot;
     &middot;&middot;&middot; b q'b &middot;&middot;&middot; a q'b &middot;&middot;&middot;
</pre>

<li>
Consider the following polynomial-time reduction from CLIQUE to SAT.

<br><br>

We begin by a description of the reduction of the following example graph G, then generalize.

<br><br>
<img src="assign-3-Q6-1.svg">
<br><br>

The four nodes are encoded by 2-bit numbers 00, 01, 10, 11.
The following is an adjacency list of G listing all adjacent nodes 
(a<sub>1</sub>a<sub>2</sub>, b<sub>1</sub>b<sub>2</sub>):

<pre>
(00, 01)
(00, 10)
(01, 00)
(01, 10)
(01, 11)
(10, 00)
(10, 01)
(10, 11)
(11, 01)
(11, 10)
</pre>

This adjacency list is encoded by the formula:

<pre>
adjacent(a<sub>1</sub>, a<sub>2</sub>, b<sub>1</sub>, b<sub>2</sub>) =
(a<sub>1</sub>=0 &and; a<sub>2</sub>=0 &and; b<sub>1</sub>=0 &and; b<sub>2</sub>=1) &or;
(a<sub>1</sub>=0 &and; a<sub>2</sub>=0 &and; b<sub>1</sub>=1 &and; b<sub>2</sub>=0) &or;
...
(a<sub>1</sub>=1 &and; a<sub>2</sub>=1 &and; b<sub>1</sub>=0 &and; b<sub>2</sub>=1) &or;
(a<sub>1</sub>=1 &and; a<sub>2</sub>=1 &and; b<sub>1</sub>=1 &and; b<sub>2</sub>=0)
</pre>

a<sub>i</sub> = 0 is expressed by &not;a<sub>i</sub> and
a<sub>i</sub> = 1 is expressed by a<sub>i</sub>.
Nodes a<sub>1</sub>a<sub>2</sub> and b<sub>1</sub>b<sub>2</sub> are adjacent iff
adjacent(a<sub>1</sub>, a<sub>2</sub>, b<sub>1</sub>, b<sub>2</sub>) is true.

<br><br>

The existence of a 3-clique is encoded by &phi; with three 2-bit node variables
x<sub>1</sub>y<sub>1</sub>, x<sub>2</sub>y<sub>2</sub>, x<sub>3</sub>y<sub>3</sub>:

<pre>
&phi;(x<sub>1</sub>, y<sub>1</sub>, x<sub>2</sub>, y<sub>2</sub>, x<sub>3</sub>, y<sub>3</sub>) =
adjacent(x<sub>1</sub>, y<sub>1</sub>, x<sub>2</sub>, y<sub>2</sub>) &and; 
adjacent(x<sub>1</sub>, y<sub>1</sub>, x<sub>3</sub>, y<sub>3</sub>) &and; 
adjacent(x<sub>2</sub>, y<sub>2</sub>, x<sub>3</sub>, y<sub>3</sub>)
</pre>

Then &phi;(x<sub>1</sub>, y<sub>1</sub>, x<sub>2</sub>, y<sub>2</sub>, x<sub>3</sub>, y<sub>3</sub>)
is satisfiable iff there is a 3-clique of 
nodes x<sub>1</sub>y<sub>1</sub>, x<sub>2</sub>y<sub>2</sub>, x<sub>3</sub>y<sub>3</sub>.

<br><br>

Now the generalization.
Let n be the # of nodes of the input graph G.
If k &gt; n, G cannot have a k-clique, so the reduction immediately generates
a trivial unsatisfiable Boolean formula like x &and; &not;x.
Otherwise, the nodes 0, &hellip;, n&minus;1 are encoded by p = &lceil;log<sub>2</sub>n&rceil; bits.
The adjacency list of n nodes is then encoded by the formula 
adjacent(a<sub>1</sub>, &hellip;, a<sub>p</sub>, b<sub>1</sub>, &hellip;, b<sub>p</sub>) which is
a disjunction of 2&middot;e conjunctions, each of which containing 2p literals, where e is the # of edges of G.
Each conjunction encodes a pair of adjacent nodes in the manner illustrated in the above example.

<br><br>

The existence of a k-clique is encoded by
&phi; with k p-bit node variables

<pre>
&phi;(x<sub>1</sub><sup>1</sup>, ..., x<sub>1</sub><sup>p</sup>, ..., x<sub>k</sub><sup>1</sup>, ..., x<sub>k</sub><sup>p</sup>) =
<font size=+3>&and;</font>adjacent(x<sub>i</sub><sup>1</sup>, ..., x<sub>i</sub><sup>p</sup>, x<sub>j</sub><sup>1</sup>, ..., x<sub>j</sub><sup>p</sup>)
</pre>

where the conjunction is formed for all i, j such that
1 &le; i &lt; j &le; k.

<br><br>

<ol type=a>
<li>
Give the exact number of literals in the above &phi; for the example graph G and k =3.

<br><br>
&phi; has (2e)&middot;(2p)&middot;3 = 2&middot;5&middot;2&middot;2&middot;3 = 120 literals.
<br><br>

<li>
Give the Boolean formula generated from the following instance of CLIQUE by the reduction.
Exactly how many literals does your formula have?

<br><br>
<img src="assign-3-Q6-2.svg">
<br><br>
<img src="assign-3-sol-Q6-2.svg">
<br><br>
The six nodes are encoded by 3-bit numbers 000, 001, 010, 011, 100, 101.
The following is an adjacency list of G listing all adjacent nodes 
(a<sub>1</sub>a<sub>2</sub>a<sub>3</sub>, b<sub>1</sub>b<sub>2</sub>b<sub>3</sub>):

<pre>
(000, 001)
(000, 010)
(000, 011)
(000, 100)
(001, 000)
(001, 010)
(001, 100)
(010, 000)
(010, 001)
(010, 100)
(010, 101)
(011, 000)
(011, 100)
(100, 000)
(100, 001)
(100, 010)
(100, 011)
(100, 101)
(101, 010)
(101, 100)
</pre>

This adjacency list is encoded by the formula:

<pre>
adjacent(a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub>, b<sub>1</sub>, b<sub>2</sub>, b<sub>3</sub>) =
(a<sub>1</sub>=0 &and; a<sub>2</sub>=0 &and; a<sub>3</sub>=0 &and; b<sub>1</sub>=0 &and; b<sub>2</sub>=0 &and; b<sub>3</sub>=1) &or;
(a<sub>1</sub>=0 &and; a<sub>2</sub>=0 &and; a<sub>3</sub>=0 &and; b<sub>1</sub>=0 &and; b<sub>2</sub>=1 &and; b<sub>3</sub>=0) &or;
...
(a<sub>1</sub>=1 &and; a<sub>2</sub>=0 &and; a<sub>3</sub>=1 &and; b<sub>1</sub>=0 &and; b<sub>2</sub>=1 &and; b<sub>3</sub>=0) &or;
(a<sub>1</sub>=1 &and; a<sub>2</sub>=0 &and; a<sub>3</sub>=1 &and; b<sub>1</sub>=1 &and; b<sub>2</sub>=0 &and; b<sub>3</sub>=0)
</pre>

a<sub>i</sub> = 0 is expressed by &not;a<sub>i</sub> and
a<sub>i</sub> = 1 is expressed by a<sub>i</sub>.
Nodes a<sub>1</sub>a<sub>2</sub>a<sub>3</sub> and b<sub>1</sub>b<sub>2</sub>b<sub>3</sub> are adjacent iff
adjacent(a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub>, b<sub>1</sub>, b<sub>2</sub>, b<sub>3</sub>) is true.

<br><br>

The existence of a 4-clique is encoded by &phi; with four 3-bit node variables
x<sub>1</sub>y<sub>1</sub>z<sub>1</sub>, x<sub>2</sub>y<sub>2</sub>z<sub>2</sub>, x<sub>3</sub>y<sub>3</sub>z<sub>3</sub>, 
x<sub>4</sub>y<sub>4</sub>z<sub>4</sub>:

<pre>
&phi;(x<sub>1</sub>, y<sub>1</sub>, z<sub>1</sub>, x<sub>2</sub>, y<sub>2</sub>, z<sub>2</sub>, x<sub>3</sub>, y<sub>3</sub>, z<sub>3</sub>, x<sub>4</sub>, y<sub>4</sub>, z<sub>4</sub>) =
adjacent(x<sub>1</sub>, y<sub>1</sub>, z<sub>1</sub>, x<sub>2</sub>, y<sub>2</sub>, z<sub>2</sub>) &and; 
adjacent(x<sub>1</sub>, y<sub>1</sub>, z<sub>1</sub>, x<sub>3</sub>, y<sub>3</sub>, z<sub>3</sub>) &and; 
adjacent(x<sub>1</sub>, y<sub>1</sub>, z<sub>1</sub>, x<sub>4</sub>, y<sub>4</sub>, z<sub>4</sub>) &and;
adjacent(x<sub>2</sub>, y<sub>2</sub>, z<sub>2</sub>, x<sub>3</sub>, y<sub>3</sub>, z<sub>3</sub>) &and; 
adjacent(x<sub>2</sub>, y<sub>2</sub>, z<sub>2</sub>, x<sub>4</sub>, y<sub>4</sub>, z<sub>4</sub>) &and;
adjacent(x<sub>3</sub>, y<sub>3</sub>, z<sub>3</sub>, x<sub>4</sub>, y<sub>4</sub>, z<sub>4</sub>)
</pre>

&phi; has (2e)&middot;(2p)&middot;6 = 2&middot;10&middot;2&middot;3&middot;6 = 720 literals.
<br><br>

<li>
Give the exact number of literals in &phi; generated from any graph with n nodes and e edges, and
show that it is bounded by a polynomial of n.

<br><br>
The formula adjacent(a<sub>1</sub>, &hellip;, a<sub>p</sub>, b<sub>1</sub>, &hellip;, b<sub>p</sub>) has
(2e)&middot;(2p) =
4&middot;e&middot;p = 4&middot;e&middot;&lceil;log<sub>2</sub>n&rceil; literals.
Since &phi; is a conjunction of k(k&minus;1)/2 "adjacent" formulas,
it has (4&middot;e&middot;&lceil;log<sub>2</sub>n&rceil;) &times; k(k&minus;1)/2 literals.
Since k &le; n,
this is &le; (4&middot;e&middot;&lceil;log<sub>2</sub>n&rceil;) &times; n(n&minus;1)/2.
Since e &le; n(n&minus;1)/2, it is O(n<sup>4</sup>&middot;log<sub>2</sub>n), bounded by a polynomial of n.
</ol>

</ol>

</body>
</html>
